/*
 * Falcon signature generation.
 *
 * ==========================(LICENSE BEGIN)============================
 *
 * Copyright (c) 2017-2019  Falcon Project
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ===========================(LICENSE END)=============================
 *
 * @author   Thomas Pornin <thomas.pornin@nccgroup.com>
 */

#include "header.h"

/* =================================================================== */

/*
 * Compute degree N from logarithm 'logn'.
 */
#define MKN(logn)   ((size_t)1 << (logn))

/* =================================================================== */
/*
 * Binary case:
 *   N = 2^logn
 *   phi = X^N+1
 */

/*
 * Get the size of the LDL tree for an input with polynomials of size
 * 2^logn. The size is expressed in the number of elements.
 */
unsigned ffLDL_treesize(unsigned logn)
{
	/*
	 * For logn = 0 (polynomials are constant), the "tree" is a
	 * single element. Otherwise, the tree node has size 2^logn, and
	 * has two child trees for size logn-1 each. Thus, treesize s()
	 * must fulfill these two relations:
	 *
	 *   s(0) = 1
	 *   s(logn) = (2^logn) + 2*s(logn-1)
	 */
	return (logn + 1) << logn;
}

static const int32_t ffSampling_logn1024[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 
 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 
 2, 2, 3, 2, 2, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 
 4, 3, 2, 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 
 2, 4, 3, 2, 2, 3, 2, 2, 8, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 
 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 
 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 
 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 
 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 9, 8, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 
 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 
 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 
 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 
 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 8, 7, 6, 5, 4, 3, 2, 
 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 6, 5, 4, 3, 
 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 7, 6, 5, 
 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 6, 
 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2};


static const int32_t ffSampling_logn512[] = {9, 8, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 
 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 
 2, 2, 3, 2, 2, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 2, 
 4, 3, 2, 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 2, 3, 2, 
 2, 4, 3, 2, 2, 3, 2, 2, 8, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 2, 
 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 4, 3, 
 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 7, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 5, 
 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 6, 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2, 
 5, 4, 3, 2, 2, 3, 2, 2, 4, 3, 2, 2, 3, 2, 2};


 static const int32_t t0_offset1024[] = {0, 3072, 4608, 5376, 5760, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 
 6112, 6080, 6120, 6112, 5632, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 
 6120, 6112, 6080, 6120, 6112, 5120, 5760, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 
 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5632, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 
 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 4096, 5376, 5760, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 
 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5632, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 
 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5120, 5760, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 
 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5632, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 
 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 2048, 4608, 5376, 5760, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 
 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5632, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 
 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5120, 5760, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 
 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5632, 5952, 6048, 6096, 6120, 6112, 6080, 6120, 
 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 4096, 5376, 5760, 5952, 6048, 6096, 6120, 
 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5632, 5952, 6048, 6096, 
 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5120, 5760, 5952, 
 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5632, 
 5952, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112, 5888, 6048, 6096, 6120, 6112, 6080, 6120, 6112, 6016, 6096, 6120, 6112, 6080, 6120, 6112,};
 
 static const int32_t t0_offset512[] = {0, 1536, 2304, 2688, 2880, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2816, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 
 3040, 3008, 3048, 3040, 2560, 2880, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2816, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 
 3048, 3040, 3008, 3048, 3040, 2048, 2688, 2880, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2816, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 
 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2560, 2880, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2816, 2976, 3024, 3048, 3040, 3008, 3048, 
 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 1024, 2304, 2688, 2880, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2816, 2976, 3024, 3048, 
 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2560, 2880, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2816, 2976, 3024, 
 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2048, 2688, 2880, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2816, 
 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 2560, 2880, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040, 
 2816, 2976, 3024, 3048, 3040, 3008, 3048, 3040, 2944, 3024, 3048, 3040, 3008, 3048, 3040};

 static const int32_t t1_offset1024[] = {1024, 3584, 4864, 5504, 5824, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 
 6116, 6088, 6124, 6116, 5696, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 
 6124, 6116, 6088, 6124, 6116, 5248, 5824, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 
 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5696, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 
 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 4352, 5504, 5824, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 
 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5696, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 
 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5248, 5824, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 
 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5696, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 
 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 2560, 4864, 5504, 5824, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 
 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5696, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 
 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5248, 5824, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 
 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5696, 5984, 6064, 6104, 6124, 6116, 6088, 6124, 
 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 4352, 5504, 5824, 5984, 6064, 6104, 6124, 
 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5696, 5984, 6064, 6104, 
 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5248, 5824, 5984, 
 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5696, 
 5984, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116, 5920, 6064, 6104, 6124, 6116, 6088, 6124, 6116, 6032, 6104, 6124, 6116, 6088, 6124, 6116};

 static const int32_t t1_offset512[] = {512, 1792, 2432, 2752, 2912, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2848, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 
 3044, 3016, 3052, 3044, 2624, 2912, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2848, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 
 3052, 3044, 3016, 3052, 3044, 2176, 2752, 2912, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2848, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 
 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2624, 2912, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2848, 2992, 3032, 3052, 3044, 3016, 3052, 
 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 1280, 2432, 2752, 2912, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2848, 2992, 3032, 3052, 
 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2624, 2912, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2848, 2992, 3032, 
 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2176, 2752, 2912, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2848, 
 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 2624, 2912, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044, 
 2848, 2992, 3032, 3052, 3044, 3016, 3052, 3044, 2960, 3032, 3052, 3044, 3016, 3052, 3044};

 static const int32_t tree_offset_ff512[] = {0, 2816, 4096, 4672, 4928, 5040, 5088, 5108, 5096, 5056, 5076, 5064, 4960, 5008, 5028, 5016, 4976, 4996, 4984, 4736, 4848, 4896, 4916, 4904, 4864, 4884, 4872, 4768, 4816, 4836, 
 4824, 4784, 4804, 4792, 4224, 4480, 4592, 4640, 4660, 4648, 4608, 4628, 4616, 4512, 4560, 4580, 4568, 4528, 4548, 4536, 4288, 4400, 4448, 4468, 4456, 4416, 4436, 4424, 4320, 4368, 
 4388, 4376, 4336, 4356, 4344, 3072, 3648, 3904, 4016, 4064, 4084, 4072, 4032, 4052, 4040, 3936, 3984, 4004, 3992, 3952, 3972, 3960, 3712, 3824, 3872, 3892, 3880, 3840, 3860, 3848, 
 3744, 3792, 3812, 3800, 3760, 3780, 3768, 3200, 3456, 3568, 3616, 3636, 3624, 3584, 3604, 3592, 3488, 3536, 3556, 3544, 3504, 3524, 3512, 3264, 3376, 3424, 3444, 3432, 3392, 3412, 
 3400, 3296, 3344, 3364, 3352, 3312, 3332, 3320, 512, 1792, 2368, 2624, 2736, 2784, 2804, 2792, 2752, 2772, 2760, 2656, 2704, 2724, 2712, 2672, 2692, 2680, 2432, 2544, 2592, 2612, 
 2600, 2560, 2580, 2568, 2464, 2512, 2532, 2520, 2480, 2500, 2488, 1920, 2176, 2288, 2336, 2356, 2344, 2304, 2324, 2312, 2208, 2256, 2276, 2264, 2224, 2244, 2232, 1984, 2096, 2144, 
 2164, 2152, 2112, 2132, 2120, 2016, 2064, 2084, 2072, 2032, 2052, 2040, 768, 1344, 1600, 1712, 1760, 1780, 1768, 1728, 1748, 1736, 1632, 1680, 1700, 1688, 1648, 1668, 1656, 1408, 
 1520, 1568, 1588, 1576, 1536, 1556, 1544, 1440, 1488, 1508, 1496, 1456, 1476, 1464, 896, 1152, 1264, 1312, 1332, 1320, 1280, 1300, 1288, 1184, 1232, 1252, 1240, 1200, 1220, 1208, 
 960, 1072, 1120, 1140, 1128, 1088, 1108, 1096, 992, 1040, 1060, 1048, 1008, 1028, 1016};

 static const int32_t tree_offset_ff1024[] = {0, 6144, 8960, 10240, 10816, 11072, 11184, 11232, 11252, 11240, 11200, 11220, 11208, 11104, 11152, 11172, 11160, 11120, 11140, 11128, 10880, 10992, 11040, 11060, 11048, 11008, 11028, 11016, 10912, 10960, 10980, 
 10968, 10928, 10948, 10936, 10368, 10624, 10736, 10784, 10804, 10792, 10752, 10772, 10760, 10656, 10704, 10724, 10712, 10672, 10692, 10680, 10432, 10544, 10592, 10612, 10600, 10560, 10580, 10568, 10464, 10512, 
 10532, 10520, 10480, 10500, 10488, 9216, 9792, 10048, 10160, 10208, 10228, 10216, 10176, 10196, 10184, 10080, 10128, 10148, 10136, 10096, 10116, 10104, 9856, 9968, 10016, 10036, 10024, 9984, 10004, 9992, 
 9888, 9936, 9956, 9944, 9904, 9924, 9912, 9344, 9600, 9712, 9760, 9780, 9768, 9728, 9748, 9736, 9632, 9680, 9700, 9688, 9648, 9668, 9656, 9408, 9520, 9568, 9588, 9576, 9536, 9556, 
 9544, 9440, 9488, 9508, 9496, 9456, 9476, 9464, 6656, 7936, 8512, 8768, 8880, 8928, 8948, 8936, 8896, 8916, 8904, 8800, 8848, 8868, 8856, 8816, 8836, 8824, 8576, 8688, 8736, 8756, 
 8744, 8704, 8724, 8712, 8608, 8656, 8676, 8664, 8624, 8644, 8632, 8064, 8320, 8432, 8480, 8500, 8488, 8448, 8468, 8456, 8352, 8400, 8420, 8408, 8368, 8388, 8376, 8128, 8240, 8288, 
 8308, 8296, 8256, 8276, 8264, 8160, 8208, 8228, 8216, 8176, 8196, 8184, 6912, 7488, 7744, 7856, 7904, 7924, 7912, 7872, 7892, 7880, 7776, 7824, 7844, 7832, 7792, 7812, 7800, 7552, 
 7664, 7712, 7732, 7720, 7680, 7700, 7688, 7584, 7632, 7652, 7640, 7600, 7620, 7608, 7040, 7296, 7408, 7456, 7476, 7464, 7424, 7444, 7432, 7328, 7376, 7396, 7384, 7344, 7364, 7352, 
 7104, 7216, 7264, 7284, 7272, 7232, 7252, 7240, 7136, 7184, 7204, 7192, 7152, 7172, 7160, 1024, 3840, 5120, 5696, 5952, 6064, 6112, 6132, 6120, 6080, 6100, 6088, 5984, 6032, 6052, 
 6040, 6000, 6020, 6008, 5760, 5872, 5920, 5940, 5928, 5888, 5908, 5896, 5792, 5840, 5860, 5848, 5808, 5828, 5816, 5248, 5504, 5616, 5664, 5684, 5672, 5632, 5652, 5640, 5536, 5584, 
 5604, 5592, 5552, 5572, 5560, 5312, 5424, 5472, 5492, 5480, 5440, 5460, 5448, 5344, 5392, 5412, 5400, 5360, 5380, 5368, 4096, 4672, 4928, 5040, 5088, 5108, 5096, 5056, 5076, 5064, 
 4960, 5008, 5028, 5016, 4976, 4996, 4984, 4736, 4848, 4896, 4916, 4904, 4864, 4884, 4872, 4768, 4816, 4836, 4824, 4784, 4804, 4792, 4224, 4480, 4592, 4640, 4660, 4648, 4608, 4628, 
 4616, 4512, 4560, 4580, 4568, 4528, 4548, 4536, 4288, 4400, 4448, 4468, 4456, 4416, 4436, 4424, 4320, 4368, 4388, 4376, 4336, 4356, 4344, 1536, 2816, 3392, 3648, 3760, 3808, 3828, 
 3816, 3776, 3796, 3784, 3680, 3728, 3748, 3736, 3696, 3716, 3704, 3456, 3568, 3616, 3636, 3624, 3584, 3604, 3592, 3488, 3536, 3556, 3544, 3504, 3524, 3512, 2944, 3200, 3312, 3360, 
 3380, 3368, 3328, 3348, 3336, 3232, 3280, 3300, 3288, 3248, 3268, 3256, 3008, 3120, 3168, 3188, 3176, 3136, 3156, 3144, 3040, 3088, 3108, 3096, 3056, 3076, 3064, 1792, 2368, 2624, 
 2736, 2784, 2804, 2792, 2752, 2772, 2760, 2656, 2704, 2724, 2712, 2672, 2692, 2680, 2432, 2544, 2592, 2612, 2600, 2560, 2580, 2568, 2464, 2512, 2532, 2520, 2480, 2500, 2488, 1920, 
 2176, 2288, 2336, 2356, 2344, 2304, 2324, 2312, 2208, 2256, 2276, 2264, 2224, 2244, 2232, 1984, 2096, 2144, 2164, 2152, 2112, 2132, 2120, 2016, 2064, 2084, 2072, 2032, 2052, 2040};

 static const int32_t z0_offset1024[] = {2048, 4096, 5120, 5632, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 
 6128, 6112, 6128, 6128, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 
 6128, 6128, 6112, 6128, 6128, 5632, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 
 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 
 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5120, 5632, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 
 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 
 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5632, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 
 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 
 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 4096, 5120, 5632, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 
 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 
 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5632, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 
 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5888, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 
 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5120, 5632, 5888, 6016, 6080, 6112, 6128, 
 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5888, 6016, 6080, 6112, 
 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5632, 5888, 6016, 
 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 5888, 
 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6016, 6080, 6112, 6128, 6128, 6112, 6128, 6128, 6080, 6112, 6128, 6128, 6112, 6128, 6128};

 static const int32_t z0_offset512[] = {1024, 2048, 2560, 2816, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 
 3056, 3040, 3056, 3056, 2816, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 
 3056, 3056, 3040, 3056, 3056, 2560, 2816, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 
 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2816, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 
 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2048, 2560, 2816, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2944, 3008, 3040, 3056, 
 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2816, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2944, 3008, 3040, 
 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2560, 2816, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2944, 
 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 2816, 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 
 2944, 3008, 3040, 3056, 3056, 3040, 3056, 3056, 3008, 3040, 3056, 3056, 3040, 3056, 3056};

static const int32_t z1_offset1024[] = {3072, 4608, 5376, 5760, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 
 6132, 6120, 6132, 6132, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 
 6132, 6132, 6120, 6132, 6132, 5760, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 
 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 
 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5376, 5760, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 
 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 
 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5760, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 
 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 
 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 4608, 5376, 5760, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 
 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 
 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5760, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 
 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5952, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 
 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5376, 5760, 5952, 6048, 6096, 6120, 6132, 
 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5952, 6048, 6096, 6120, 
 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5760, 5952, 6048, 
 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 5952, 
 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6048, 6096, 6120, 6132, 6132, 6120, 6132, 6132, 6096, 6120, 6132, 6132, 6120, 6132, 6132};

static const int32_t z1_offset512[] = {1536, 2304, 2688, 2880, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 
 3060, 3048, 3060, 3060, 2880, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 
 3060, 3060, 3048, 3060, 3060, 2688, 2880, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 
 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2880, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 
 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2304, 2688, 2880, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2976, 3024, 3048, 3060, 
 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2880, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2976, 3024, 3048, 
 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2688, 2880, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2976, 
 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 2880, 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 
 2976, 3024, 3048, 3060, 3060, 3048, 3060, 3060, 3024, 3048, 3060, 3060, 3048, 3060, 3060};

 static const int32_t tmp_offset1024[] = {4096, 5120, 5632, 5888, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 
 6136, 6128, 6136, 6136, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 
 6136, 6136, 6128, 6136, 6136, 5888, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 
 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 
 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 5632, 5888, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 
 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 
 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 5888, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 
 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 
 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 5120, 5632, 5888, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 
 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 
 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 5888, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 
 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6016, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 
 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 5632, 5888, 6016, 6080, 6112, 6128, 6136, 
 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6016, 6080, 6112, 6128, 
 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 5888, 6016, 6080, 
 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6016, 
 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6080, 6112, 6128, 6136, 6136, 6128, 6136, 6136, 6112, 6128, 6136, 6136, 6128, 6136, 6136};


 static const int32_t tmp_offset512[] = {2048, 2560, 2816, 2944, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 
 3064, 3056, 3064, 3064, 2944, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 
 3064, 3064, 3056, 3064, 3064, 2816, 2944, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 
 3040, 3056, 3064, 3064, 3056, 3064, 3064, 2944, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 
 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 2560, 2816, 2944, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3008, 3040, 3056, 3064, 
 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 2944, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3008, 3040, 3056, 
 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 2816, 2944, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3008, 
 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 2944, 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 
 3008, 3040, 3056, 3064, 3064, 3056, 3064, 3064, 3040, 3056, 3064, 3064, 3056, 3064, 3064};

static const int32_t back1_global1024[] = {8, 9, 11, 12, 15, 16, 18, 19, 23, 24, 26, 27, 30, 31, 33, 34, 39, 40, 42, 43, 46, 47, 49, 50, 54, 55, 57, 58, 61, 62, 64, 65, 71, 72, 74, 75,
78, 79, 81, 82, 86, 87, 89, 90, 93, 94, 96, 97, 102, 103, 105, 106, 109, 110, 112, 113, 117, 118, 120,  121, 124, 125, 127, 128, 135, 136, 138, 139, 142, 143, 145, 146, 150, 
151, 153, 154, 157, 158, 160, 161, 166, 167, 169, 170, 173, 174, 176, 177, 181, 182, 184, 185, 188, 189, 191, 192, 198, 199, 201, 202, 205, 206, 208, 209, 213, 214, 216, 217, 
220, 221, 223, 224, 229, 230, 232, 233, 236, 237, 239, 240,  244, 245, 247, 248, 251, 252, 254, 255, 263, 264, 266, 267, 270,  271, 273, 274, 278, 279, 281, 282, 285, 286, 288,
289, 294, 295, 297, 298, 301, 302, 304, 305, 309, 310, 312, 313, 316, 317, 319, 320, 326, 327, 329, 330,  333, 334, 336, 337, 341, 342, 344, 345, 348, 349, 351, 352, 357, 358, 360, 
361, 364, 365, 367, 368, 372, 373, 375, 376, 379, 380, 382, 383, 390, 391, 393, 394, 397, 398, 400, 401, 405, 406, 408, 409, 412, 413, 415, 416, 421, 422, 424, 425, 428, 429, 431, 432, 
436, 437, 439, 440, 443, 444, 446, 447, 453, 454, 456, 457, 460, 461, 463, 464, 468, 469, 471, 472, 475, 476, 478, 479, 484, 485, 487, 488, 491, 492, 494, 495, 499, 500, 502, 503, 506, 507, 509};

static const int32_t back1_global512[] = {7, 8, 10, 11, 14, 15, 17, 18, 22, 23, 25, 26, 29, 30, 32, 33, 38, 39, 41, 42, 45, 46, 48, 49, 53, 54, 56, 57, 60, 61, 63, 64, 70, 71, 73, 74, 77, 78, 80, 81, 85, 86, 88, 89, 92, 93, 95, 96, 101, 102, 104, 105, 108, 109, 111, 112, 116, 117, 119, 120, 123, 124, 126, 127, 134, 135, 137, 138, 141, 142, 144, 145, 149, 150, 152, 153, 156, 157, 159, 160, 165, 166, 168, 169, 172, 173, 175, 176, 180, 181, 183, 184, 187, 188, 190, 191, 197, 198, 200, 201, 204, 205, 207, 208, 212, 213, 215, 216, 219, 220, 222, 223, 228, 229, 231, 232, 235, 236, 238, 239, 243, 244, 246, 247, 250, 251, 253};

static const int32_t back2_global1024[] = { 9, 12, 12, 16, 19, 19, 19, 24, 27, 27, 31, 34, 34, 34, 34, 40, 43, 43, 47, 50, 50, 50, 55, 58, 58, 62, 65, 65, 65, 65, 65, 72, 75, 75, 79, 82, 82, 82, 87, 90,
 90, 94, 97, 97, 97, 97, 103, 106, 106, 110, 113, 113, 113, 118, 121, 121, 125, 128, 128, 128, 128, 128, 128, 136, 139, 139, 143, 146, 146, 146, 151, 154, 154, 158, 161, 161, 161, 161, 167, 170, 170,
 174, 177, 177, 177, 182, 185, 185, 189, 192, 192, 192, 192, 192, 199, 202, 202, 206, 209, 209, 209, 214, 217, 217, 221, 224, 224, 224, 224, 230, 233, 233, 237, 240,  240, 240, 245, 248, 248, 252, 255,
 255, 255, 255, 255, 255, 255, 264, 267, 267, 271, 274, 274, 274, 279, 282, 282, 286, 289, 289, 289, 289, 295, 298, 298, 302, 305, 305, 305, 310, 313, 313, 317, 320, 320, 320, 320, 320, 327, 330, 
 330, 334, 337, 337, 337, 342, 345, 345, 349, 352, 352, 352, 352, 358, 361, 361, 365, 368, 368, 368, 373, 376, 376, 380, 383, 383, 383, 383, 383, 383, 391, 394, 394, 398, 401, 401, 401, 406, 409, 409, 
 413, 416, 416, 416, 416, 422, 425, 425, 429, 432, 432, 432, 437, 440, 440, 444, 447, 447, 447, 447, 447, 454, 457, 457, 461, 464, 464, 464, 469, 472, 472, 476, 479, 479, 479, 479, 485, 488, 488, 492, 
 495, 495, 495, 500, 503, 503, 507, 510, 510, 510, 510, 510, 510, 510, 510};

static const int32_t back2_global512[] = {8, 11, 11, 15, 18, 18, 18, 23, 26, 26, 30, 33, 33, 33, 33, 39, 42, 42, 46, 49, 49, 49, 54, 57, 57, 61, 64, 64, 64, 64, 64, 71, 74, 74, 78, 81, 81, 81, 86, 89, 89, 93, 96, 96, 96, 96, 102, 105, 105, 109, 112, 112, 112, 117, 120, 120, 124, 127, 127, 127, 127, 127, 127, 135, 138, 138, 142, 145, 145, 145, 150, 153, 153, 157, 160, 160, 160, 160, 166, 169, 169, 173, 176, 176, 176, 181, 184, 184, 188, 191, 191, 191, 191, 191, 198, 201, 201, 205, 208, 208, 208, 213, 216, 216, 220, 223, 223, 223, 223, 229, 232, 232, 236, 239, 239, 239, 244, 247, 247, 251, 254, 254, 254, 254, 254, 254, 254};

static const int32_t back1_local1024[] = {7, 6, 10, 5, 14, 13, 17, 4, 22, 21, 25, 20, 29, 28, 32, 3, 38, 37, 41, 36, 45, 44, 48, 35, 53, 52, 56, 51, 60, 
 59, 63, 2, 70, 69, 73, 68, 77, 76, 80, 67, 85, 84, 88, 83, 92, 91, 95, 66, 101, 100, 104, 99, 108, 107, 111, 98, 116, 115, 119, 114, 123, 122, 126, 1, 134, 133, 137, 132, 141, 140, 144, 131, 149, 148, 152, 147, 156, 155, 159, 130, 165, 164, 168, 163, 172, 171, 175, 162, 180, 
 179, 183, 178, 187, 186, 190, 129, 197, 196, 200, 195, 204, 203, 207, 194, 212, 211, 215, 210, 
 219, 218, 222, 193, 228, 227, 231, 226, 235, 234, 238, 225, 243, 242, 246, 241, 250, 249, 253, 0, 
 262, 261, 265, 260, 269, 268, 272, 259, 277, 276, 280, 275, 284, 283, 287, 258, 293, 292, 296, 291, 300, 
 299, 303, 290, 308, 307, 311, 306, 315, 314, 318, 257, 325, 324, 328, 323, 332, 331, 335, 322, 340, 339, 343, 338, 347, 346, 350, 321, 356, 355, 359, 354, 363, 362, 366, 353, 371, 370, 374, 369, 378, 377, 381, 256, 389, 388, 392, 387, 396, 395, 399, 386, 404, 403, 407, 402, 411, 410, 414, 385, 420, 
 419, 423, 418, 427, 426, 430, 417, 435, 434, 438, 433, 442, 441, 445, 384, 452, 451, 455, 450, 
 459, 458, 462, 449, 467, 466, 470, 465, 474, 473, 477, 448, 483, 482, 486, 481, 490, 489, 493, 480, 
 498, 497, 501, 496, 505, 504, 508};

 static const int32_t back1_local512[] = {6, 5, 9, 4, 13, 12, 16, 3, 21, 20, 24, 19, 28, 27, 31, 2, 37, 36, 40, 35, 44, 43, 47, 34, 52, 51, 55, 50, 59, 58, 62, 1, 69, 68, 72, 67, 76, 75, 79, 66, 84, 83, 87, 82, 91, 90, 94, 65, 100, 99, 103, 98, 107, 106, 110, 97, 115, 114, 118, 113, 122, 121, 125, 0, 133, 132, 136, 131, 140, 139, 143, 130, 148, 147, 151, 146, 155, 154, 158, 129, 164, 163, 167, 162, 171, 170, 174, 161, 179, 178, 182, 177, 186, 185, 189, 128, 196, 195, 199, 194, 203, 202, 206, 193, 211, 210, 214, 209, 218, 217, 221, 192, 227, 226, 230, 225, 234, 233, 237, 224, 242, 241, 245, 240, 249, 248, 252};

static const int32_t back2_local1024[] = {7, 10, 6, 14, 17, 13, 5, 22, 25, 21, 29, 32, 28, 20, 4, 38, 41, 37, 45, 48, 44, 36, 53, 56, 52, 60, 
 63, 59, 51, 35, 3, 70, 73, 69, 77, 80, 76, 68, 85, 88, 84, 92, 95, 91, 83, 67, 101, 104, 100, 108, 111, 107, 99, 116, 119, 115, 123, 126, 122, 114, 98, 66, 2, 134, 137, 133, 141, 144, 140, 132, 149, 152, 148, 156, 159, 155, 147, 131, 165, 168, 164, 172, 175, 171, 163, 180, 
 183, 179, 187, 190, 186, 178, 162, 130, 197, 200, 196, 204, 207, 203, 195, 212, 215, 211, 219, 222, 218, 210, 
 194, 228, 231, 227, 235, 238, 234, 226, 243, 246, 242, 250, 253, 249, 241, 225, 193, 129, 1, 262, 265, 261, 269, 272, 268, 260, 277, 280, 276, 284, 287, 283, 275, 259, 293, 296, 292, 300, 
 303, 299, 291, 308, 311, 307, 315, 318, 314, 306, 290, 258, 325, 328, 324, 332, 335, 331, 323, 340, 343, 339, 347, 350, 346, 338, 322, 356, 359, 355, 363, 366, 362, 354, 371, 374, 370, 378, 381, 377, 369, 353, 321, 257, 389, 392, 388, 396, 399, 395, 387, 404, 407, 403, 411, 414, 410, 402, 386, 420, 
 423, 419, 427, 430, 426, 418, 435, 438, 434, 442, 445, 441, 433, 417, 385, 452, 455, 451, 459, 462, 458, 450, 
 467, 470, 466, 474, 477, 473, 465, 449, 483, 486, 482, 490, 493, 489, 481, 498, 501, 497, 505, 508, 504, 496, 480, 
 448, 384, 256, 0};

 static const int32_t back2_local512[] = {6, 9, 5, 13, 16, 12, 4, 21, 24, 20, 28, 31, 27, 19, 3, 37, 40, 36, 44, 47, 43, 35, 52, 55, 51, 59, 62, 58, 50, 34, 2, 69, 72, 68, 76, 79, 75, 67, 84, 87, 83, 91, 94, 90, 82, 66, 100, 103, 99, 107, 110, 106, 98, 115, 118, 114, 122, 125, 121, 113, 97, 65, 1, 133, 136, 132, 140, 143, 139, 131, 148, 151, 147, 155, 158, 154, 146, 130, 164, 167, 163, 171, 174, 170, 162, 179, 182, 178, 186, 189, 185, 177, 161, 129, 196, 199, 195, 203, 206, 202, 194, 211, 214, 210, 218, 221, 217, 209, 193, 227, 230, 226, 234, 237, 233, 225, 242, 245, 241, 249, 252, 248, 240, 224, 192, 128, 0};

 

void ffSampling_fft_it(void *samp_ctx, const fpr *tree, const fpr *t0)
{
	size_t n, hn;
	const fpr *tree0, *tree1;
	int back1_cnt = 0;
	int back2_cnt = 0;
	double *base_adr;
	base_adr = t0;

		// const int n_it = 255;
		// const int *t0_offset =             t0_offset512;
		// const int *t1_offset =             t1_offset512;
		// const int *z0_offset =             z0_offset512;
		// const int *z1_offset =             z1_offset512;
		// const int *tmp_offset =           tmp_offset512;
		// const int *tree_offset_ff =   tree_offset_ff512;
		// const int *ffSampling_logn = ffSampling_logn512;
		// const int *back1_global =       back1_global512;
		// const int *back2_global =       back2_global512;
		// const int *back1_local =         back1_local512;
		// const int *back2_local =         back2_local512;

		const int n_it = 511;
		const int *t0_offset =             t0_offset1024;
		const int *t1_offset =             t1_offset1024;
		const int *z0_offset =             z0_offset1024;
		const int *z1_offset =             z1_offset1024;
		const int *tmp_offset =           tmp_offset1024;
		const int *tree_offset_ff =   tree_offset_ff1024;
		const int *ffSampling_logn = ffSampling_logn1024;
		const int *back1_global =       back1_global1024;
		const int *back2_global =       back2_global1024;
		const int *back1_local =         back1_local1024;
		const int *back2_local =         back2_local1024;

	for(int i = 0; i<n_it; ++i)
	{

#pragma HLS LOOP_TRIPCOUNT max=511
		if (ffSampling_logn[i] == 2) {
			
			fpr x0, x1, y0, y1, w0, w1, w2, w3, sigma;
			fpr a_re, a_im, b_re, b_im, c_re, c_im;
			
			tree0 = tree + tree_offset_ff[i] + 4;
			tree1 = tree + tree_offset_ff[i] + 8;
			fpr * tree_tmp = tree + tree_offset_ff[i];
			/*
			* We split t1 into w*, then do the recursive invocation,
			* with output in w*. We finally merge back into z1.
			*/
			double * t1_tmp = base_adr + t1_offset[i];

// #pragma HLS ARRAY_PARTITION variable=t1_tmp type=complete
			a_re = t1_tmp[0];
			a_im = t1_tmp[2];
			b_re = t1_tmp[1];
			b_im = t1_tmp[3];
			c_re = fpr_add(a_re, b_re);
			c_im = fpr_add(a_im, b_im);
			w0 = fpr_half(c_re);
			w1 = fpr_half(c_im);
			c_re = fpr_sub(a_re, b_re);
			c_im = fpr_sub(a_im, b_im);
			w2 = fpr_mul(fpr_add(c_re, c_im), fpr_invsqrt8);
			w3 = fpr_mul(fpr_sub(c_im, c_re), fpr_invsqrt8);

			x0 = w2;
			x1 = w3;
			sigma = tree1[3];
			w2 = fpr_of(sampler(samp_ctx, x0, sigma));
			w3 = fpr_of(sampler(samp_ctx, x1, sigma));
			a_re = fpr_sub(x0, w2);
			a_im = fpr_sub(x1, w3);
			b_re = tree1[0];
			b_im = tree1[1];
			c_re = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
			c_im = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
			x0 = fpr_add(c_re, w0);
			x1 = fpr_add(c_im, w1);
			sigma = tree1[2];
			w0 = fpr_of(sampler(samp_ctx, x0, sigma));
			w1 = fpr_of(sampler(samp_ctx, x1, sigma));

			a_re = w0;
			a_im = w1;
			b_re = w2;
			b_im = w3;
			c_re = fpr_mul(fpr_sub(b_re, b_im), fpr_invsqrt2);
			c_im = fpr_mul(fpr_add(b_re, b_im), fpr_invsqrt2);

			double * z1_tmp = base_adr + z1_offset[i];
			z1_tmp[0] = w0 = fpr_add(a_re, c_re);
			z1_tmp[2] = w2 = fpr_add(a_im, c_im);
			z1_tmp[1] = w1 = fpr_sub(a_re, c_re);
			z1_tmp[3] = w3 = fpr_sub(a_im, c_im);
			/*
			* Compute tb0 = t0 + (t1 - z1) * L. Value tb0 ends up in w*.
			*/
			w0 = fpr_sub(t1_tmp[0], w0);
			w1 = fpr_sub(t1_tmp[1], w1);
			w2 = fpr_sub(t1_tmp[2], w2);
			w3 = fpr_sub(t1_tmp[3], w3);
			a_re = w0;
			a_im = w2;
			b_re = tree_tmp[0];
			b_im = tree_tmp[2];

			w0 = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
			w2 = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
			a_re = w1;
			a_im = w3;
			b_re = tree_tmp[1];
			b_im = tree_tmp[3];
			w1 = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
			w3 = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
			double* t0_tmp = base_adr + t0_offset[i];

			w0 = fpr_add(w0, t0_tmp[0]);
			w1 = fpr_add(w1, t0_tmp[1]);
			w2 = fpr_add(w2, t0_tmp[2]);
			w3 = fpr_add(w3, t0_tmp[3]);

			/*
			* Second recursive invocation.
			*/
			a_re = w0;
			a_im = w2;
			b_re = w1;
			b_im = w3;
			c_re = fpr_add(a_re, b_re);
			c_im = fpr_add(a_im, b_im);
			w0 = fpr_half(c_re);
			w1 = fpr_half(c_im);
			c_re = fpr_sub(a_re, b_re);
			c_im = fpr_sub(a_im, b_im);
			w2 = fpr_mul(fpr_add(c_re, c_im), fpr_invsqrt8);
			w3 = fpr_mul(fpr_sub(c_im, c_re), fpr_invsqrt8);

			x0 = w2;
			x1 = w3;
			sigma = tree0[3];
			w2 = y0 = fpr_of(sampler(samp_ctx, x0, sigma));
			w3 = y1 = fpr_of(sampler(samp_ctx, x1, sigma));
			a_re = fpr_sub(x0, y0);
			a_im = fpr_sub(x1, y1);
			b_re = tree0[0];
			b_im = tree0[1];
			c_re = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
			c_im = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
			x0 = fpr_add(c_re, w0);
			x1 = fpr_add(c_im, w1);
			sigma = tree0[2];
			w0 = fpr_of(sampler(samp_ctx, x0, sigma));
			w1 = fpr_of(sampler(samp_ctx, x1, sigma));

			a_re = w0;
			a_im = w1;
			b_re = w2;
			b_im = w3;
			c_re = fpr_mul(fpr_sub(b_re, b_im), fpr_invsqrt2);
			c_im = fpr_mul(fpr_add(b_re, b_im), fpr_invsqrt2);

			double * z0_tmp = base_adr + z0_offset[i];

			z0_tmp[0] = fpr_add(a_re, c_re);
			z0_tmp[2] = fpr_add(a_im, c_im);
			z0_tmp[1] = fpr_sub(a_re, c_re);
			z0_tmp[3] = fpr_sub(a_im, c_im);

		}
		else{
			n = (size_t)1 << ffSampling_logn[i];
			hn = n >> 1;
			// printf("%d, %d, %d, %d \n", z1_offset[i], z1_offset[i] + hn, t1_offset[i], ffSampling_logn[i]);
			poly_split_fft(base_adr+z1_offset[i], base_adr+z1_offset[i] + hn, base_adr+t1_offset[i], ffSampling_logn[i]);
			// printf("%lf, ", *(base_adr+z1_offset[i]));
		}
		for(;;){
			#pragma HLS LOOP_TRIPCOUNT max=1
			//not real max but vitis only takes max into account when calculating latency
			if(i == back2_global[back2_cnt])
			{
				double* tmp_tmp = base_adr + tmp_offset[back2_local[back2_cnt]];
				double* z0_tmp  = base_adr + z0_offset[back2_local[back2_cnt]];
				int logn_tmp = ffSampling_logn[back2_local[back2_cnt]];
				int n_tmp = (size_t)1 << logn_tmp;
				int hn_tmp = n_tmp >> 1;

				poly_merge_fft(z0_tmp, tmp_tmp, tmp_tmp + hn_tmp, logn_tmp);
				back2_cnt++;
			}
			else
				break;
		}
		if(i == back1_global[back1_cnt])
		{	
			double* tmp_tmp = base_adr + tmp_offset[back1_local[back1_cnt]];
			double* z0_tmp  = base_adr + z0_offset[back1_local[back1_cnt]];
			double* z1_tmp  = base_adr + z1_offset[back1_local[back1_cnt]];
			double* t0_tmp  = base_adr + t0_offset[back1_local[back1_cnt]];
			double* t1_tmp  = base_adr + t1_offset[back1_local[back1_cnt]];
			double* tree_tmp = tree + tree_offset_ff[back1_local[back1_cnt]];
			int logn_tmp = ffSampling_logn[back1_local[back1_cnt]];
			int n_tmp = (size_t)1 << logn_tmp;
			int hn_tmp = n_tmp >> 1;

			poly_merge_fft(z1_tmp, tmp_tmp, tmp_tmp + hn_tmp, logn_tmp);
	
			memcpy(tmp_tmp, t1_tmp, n_tmp * sizeof *t0);
			poly_sub(tmp_tmp, z1_tmp, logn_tmp);
			poly_mul_fft(tmp_tmp, tree_tmp, logn_tmp);
			poly_add(tmp_tmp, t0_tmp, logn_tmp);
			poly_split_fft(z0_tmp, z0_tmp + hn_tmp, tmp_tmp, logn_tmp);
			back1_cnt++;
		}
	}
}


void ffSampling_fft(void *samp_ctx,	fpr *z0, fpr *z1, const fpr *tree, const fpr *t0, const fpr *t1, unsigned logn, fpr *tmp)
{
	size_t n, hn;
	const fpr *tree0, *tree1;
	global_cnt++;
	int local_cnt = global_cnt;



	/*
	 * When logn == 2, we inline the last two recursion levels.
	 */
	if (logn == 2) {
		fpr x0, x1, y0, y1, w0, w1, w2, w3, sigma;
		fpr a_re, a_im, b_re, b_im, c_re, c_im;

		tree0 = tree + 4;
		tree1 = tree + 8;

		/*
		 * We split t1 into w*, then do the recursive invocation,
		 * with output in w*. We finally merge back into z1.
		 */
		a_re = t1[0];
		a_im = t1[2];
		b_re = t1[1];
		b_im = t1[3];
		c_re = fpr_add(a_re, b_re);
		c_im = fpr_add(a_im, b_im);
		w0 = fpr_half(c_re);
		w1 = fpr_half(c_im);
		c_re = fpr_sub(a_re, b_re);
		c_im = fpr_sub(a_im, b_im);
		w2 = fpr_mul(fpr_add(c_re, c_im), fpr_invsqrt8);
		w3 = fpr_mul(fpr_sub(c_im, c_re), fpr_invsqrt8);

		x0 = w2;
		x1 = w3;
		sigma = tree1[3];
		w2 = fpr_of(sampler(samp_ctx, x0, sigma));
		w3 = fpr_of(sampler(samp_ctx, x1, sigma));
		a_re = fpr_sub(x0, w2);
		a_im = fpr_sub(x1, w3);
		b_re = tree1[0];
		b_im = tree1[1];
		c_re = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
		c_im = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
		x0 = fpr_add(c_re, w0);
		x1 = fpr_add(c_im, w1);
		sigma = tree1[2];
		w0 = fpr_of(sampler(samp_ctx, x0, sigma));
		w1 = fpr_of(sampler(samp_ctx, x1, sigma));

		a_re = w0;
		a_im = w1;
		b_re = w2;
		b_im = w3;
		c_re = fpr_mul(fpr_sub(b_re, b_im), fpr_invsqrt2);
		c_im = fpr_mul(fpr_add(b_re, b_im), fpr_invsqrt2);
		z1[0] = w0 = fpr_add(a_re, c_re);
		z1[2] = w2 = fpr_add(a_im, c_im);
		z1[1] = w1 = fpr_sub(a_re, c_re);
		z1[3] = w3 = fpr_sub(a_im, c_im);

		/*
		 * Compute tb0 = t0 + (t1 - z1) * L. Value tb0 ends up in w*.
		 */
		w0 = fpr_sub(t1[0], w0);
		w1 = fpr_sub(t1[1], w1);
		w2 = fpr_sub(t1[2], w2);
		w3 = fpr_sub(t1[3], w3);

		a_re = w0;
		a_im = w2;
		b_re = tree[0];
		b_im = tree[2];
		w0 = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
		w2 = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
		a_re = w1;
		a_im = w3;
		b_re = tree[1];
		b_im = tree[3];
		w1 = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
		w3 = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));

		w0 = fpr_add(w0, t0[0]);
		w1 = fpr_add(w1, t0[1]);
		w2 = fpr_add(w2, t0[2]);
		w3 = fpr_add(w3, t0[3]);

		/*
		 * Second recursive invocation.
		 */
		a_re = w0;
		a_im = w2;
		b_re = w1;
		b_im = w3;
		c_re = fpr_add(a_re, b_re);
		c_im = fpr_add(a_im, b_im);
		w0 = fpr_half(c_re);
		w1 = fpr_half(c_im);
		c_re = fpr_sub(a_re, b_re);
		c_im = fpr_sub(a_im, b_im);
		w2 = fpr_mul(fpr_add(c_re, c_im), fpr_invsqrt8);
		w3 = fpr_mul(fpr_sub(c_im, c_re), fpr_invsqrt8);

		x0 = w2;
		x1 = w3;
		sigma = tree0[3];
		w2 = y0 = fpr_of(sampler(samp_ctx, x0, sigma));
		w3 = y1 = fpr_of(sampler(samp_ctx, x1, sigma));
		a_re = fpr_sub(x0, y0);
		a_im = fpr_sub(x1, y1);
		b_re = tree0[0];
		b_im = tree0[1];
		c_re = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
		c_im = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
		x0 = fpr_add(c_re, w0);
		x1 = fpr_add(c_im, w1);
		sigma = tree0[2];
		w0 = fpr_of(sampler(samp_ctx, x0, sigma));
		w1 = fpr_of(sampler(samp_ctx, x1, sigma));

		a_re = w0;
		a_im = w1;
		b_re = w2;
		b_im = w3;
		c_re = fpr_mul(fpr_sub(b_re, b_im), fpr_invsqrt2);
		c_im = fpr_mul(fpr_add(b_re, b_im), fpr_invsqrt2);
		z0[0] = fpr_add(a_re, c_re);
		z0[2] = fpr_add(a_im, c_im);
		z0[1] = fpr_sub(a_re, c_re);
		z0[3] = fpr_sub(a_im, c_im);

		return;
	}

	/*
	 * Case logn == 1 is reachable only when using Falcon-2 (the
	 * smallest size for which Falcon is mathematically defined, but
	 * of course way too insecure to be of any use).
	 */
	if (logn == 1) {
		fpr x0, x1, y0, y1, sigma;
		fpr a_re, a_im, b_re, b_im, c_re, c_im;

		x0 = t1[0];
		x1 = t1[1];
		sigma = tree[3];
		z1[0] = y0 = fpr_of(sampler(samp_ctx, x0, sigma));
		z1[1] = y1 = fpr_of(sampler(samp_ctx, x1, sigma));
		a_re = fpr_sub(x0, y0);
		a_im = fpr_sub(x1, y1);
		b_re = tree[0];
		b_im = tree[1];
		c_re = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
		c_im = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
		x0 = fpr_add(c_re, t0[0]);
		x1 = fpr_add(c_im, t0[1]);
		sigma = tree[2];
		z0[0] = fpr_of(sampler(samp_ctx, x0, sigma));
		z0[1] = fpr_of(sampler(samp_ctx, x1, sigma));

		return;
	}

	/*
	 * Normal end of recursion is for logn == 0. Since the last
	 * steps of the recursions were inlined in the blocks above
	 * (when logn == 1 or 2), this case is not reachable, and is
	 * retained here only for documentation purposes.

	if (logn == 0) {
		fpr x0, x1, sigma;

		x0 = t0[0];
		x1 = t1[0];
		sigma = tree[0];
		z0[0] = fpr_of(samp(samp_ctx, x0, sigma));
		z1[0] = fpr_of(samp(samp_ctx, x1, sigma));
		return;
	}

	 */

	/*
	 * General recursive case (logn >= 3).
	 */

	n = (size_t)1 << logn;
	hn = n >> 1;
	tree0 = tree + n;
	tree1 = tree + n + ffLDL_treesize(logn - 1);

	/*
	 * We split t1 into z1 (reused as temporary storage), then do
	 * the recursive invocation, with output in tmp. We finally
	 * merge back into z1.
	 */

	poly_split_fft(z1, z1 + hn, t1, logn);
	// printf("%lf, ", *(z1));
	ffSampling_fft(samp_ctx, tmp, tmp + hn,
		tree1, z1, z1 + hn, logn - 1, tmp + n);


	// printf("%lf ", tmp[0]);
	// printf("%lf ", z0[0]);
	// printf("%lf ", z1[0]);
	// printf("%lf ", t0[0]);
	// printf("%lf ", t1[0]);
	// printf("%lf ", tree[0]);
	// printf("%d ", logn);
	// printf("\n");

	poly_merge_fft(z1, tmp, tmp + hn, logn);

	/*
	 * Compute tb0 = t0 + (t1 - z1) * L. Value tb0 ends up in tmp[].
	 */
	memcpy(tmp, t1, n * sizeof *t1);
	poly_sub(tmp, z1, logn);
	poly_mul_fft(tmp, tree, logn);
	poly_add(tmp, t0, logn);

	/*
	 * Second recursive invocation.
	 */
	poly_split_fft(z0, z0 + hn, tmp, logn);
	ffSampling_fft(samp_ctx, tmp, tmp + hn,
		tree0, z0, z0 + hn, logn - 1, tmp + n);
	printf("%d, ", global_cnt);

// if(global_cnt % 30 == 0)
// 		printf("%d, \n ", global_cnt);
// 	else
// 		printf("%d, ", global_cnt);
	poly_merge_fft(z0, tmp, tmp + hn, logn);
}


void ffSampling_fft_dyntree(void *samp_ctx, fpr *t0, fpr *t1, fpr *g00, fpr *g01, fpr *g11, unsigned orig_logn, unsigned logn, fpr *tmp)
{
	size_t n, hn;
	fpr *z0, *z1;
	// global_cnt++;
	// if(global_cnt%30==0)
	// printf("%d, \n", logn);
	// else
	// 	printf("%d, ", logn);

	/*
	 * Deepest level: the LDL tree leaf value is just g00 (the
	 * array has length only 1 at this point); we normalize it
	 * with regards to sigma, then use it for sampling.
	 */
	if (logn == 0) {
		fpr leaf;

		leaf = g00[0];
		leaf = fpr_mul(fpr_sqrt(leaf), fpr_inv_sigma[orig_logn]);
		t0[0] = fpr_of(sampler(samp_ctx, t0[0], leaf));
		t1[0] = fpr_of(sampler(samp_ctx, t1[0], leaf));
		return;
	}

	n = (size_t)1 << logn;
	hn = n >> 1;

	/*
	 * Decompose G into LDL. We only need d00 (identical to g00),
	 * d11, and l10; we do that in place.
	 */
	poly_LDL_fft(g00, g01, g11, logn);

	/*
	 * Split d00 and d11 and expand them into half-size quasi-cyclic
	 * Gram matrices. We also save l10 in tmp[].
	 */
	poly_split_fft(tmp, tmp + hn, g00, logn);
	memcpy(g00, tmp, n * sizeof *tmp);
	poly_split_fft(tmp, tmp + hn, g11, logn);
	memcpy(g11, tmp, n * sizeof *tmp);
	memcpy(tmp, g01, n * sizeof *g01);
	memcpy(g01, g00, hn * sizeof *g00);
	memcpy(g01 + hn, g11, hn * sizeof *g00);

	/*
	 * The half-size Gram matrices for the recursive LDL tree
	 * building are now:
	 *   - left sub-tree: g00, g00+hn, g01
	 *   - right sub-tree: g11, g11+hn, g01+hn
	 * l10 is in tmp[].
	 */

	/*
	 * We split t1 and use the first recursive call on the two
	 * halves, using the right sub-tree. The result is merged
	 * back into tmp + 2*n.
	 */
	z1 = tmp + n;
	poly_split_fft(z1, z1 + hn, t1, logn);
	ffSampling_fft_dyntree(samp_ctx, z1, z1 + hn, g11, g11 + hn, g01 + hn, orig_logn, logn - 1, z1 + n);
	poly_merge_fft(tmp + (n << 1), z1, z1 + hn, logn);

	/*
	 * Compute tb0 = t0 + (t1 - z1) * l10.
	 * At that point, l10 is in tmp, t1 is unmodified, and z1 is
	 * in tmp + (n << 1). The buffer in z1 is free.
	 *
	 * In the end, z1 is written over t1, and tb0 is in t0.
	 */
	memcpy(z1, t1, n * sizeof *t1);
	poly_sub(z1, tmp + (n << 1), logn);
	memcpy(t1, tmp + (n << 1), n * sizeof *tmp);
	poly_mul_fft(tmp, z1, logn);
	poly_add(t0, tmp, logn);

	/*
	 * Second recursive invocation, on the split tb0 (currently in t0)
	 * and the left sub-tree.
	 */
	z0 = tmp;
	poly_split_fft(z0, z0 + hn, t0, logn);
	ffSampling_fft_dyntree(samp_ctx, z0, z0 + hn, g00, g00 + hn, g01, orig_logn, logn - 1, z0 + n);
	poly_merge_fft(t0, z0, z0 + hn, logn);
}


void ffLDL_fft_inner_it(fpr * tree, fpr * g0, unsigned logn, fpr * tmp){
	size_t n, hn;
	
	fpr *base_adr = g0;


	// int n_it = 1022;
	// const int16_t *tree_offset = tree_offset_ffLDL512;
	// const int16_t *g0_offset = g0_offset512;
	// const int16_t *g1_offset = g1_offset512;
	// const int8_t *logn_tree = logn_tree512;

	int n_it = 2046;
	const int16_t *tree_offset = tree_offset_ffLDL1024;
	const int16_t *g0_offset = g0_offset1024;
	const int16_t *g1_offset = g1_offset1024;
	const int8_t *logn_tree = logn_tree1024;

	for(int i = 0; i<n_it; ++i){
		n = MKN(logn_tree[i]);
		if (n == 1) {
			*(tree+tree_offset[i]) = *(g0+g0_offset[i]);
		}
		else{
			hn = n >> 1;
			poly_LDLmv_fft(tmp, tree+tree_offset[i], base_adr+g0_offset[i], base_adr+g1_offset[i], base_adr+g0_offset[i], logn_tree[i]);
			poly_split_fft(base_adr+g1_offset[i], base_adr+g1_offset[i]+hn, base_adr+g0_offset[i], logn_tree[i]);
			poly_split_fft(base_adr+g0_offset[i], base_adr+g0_offset[i]+hn, tmp, logn_tree[i]);
		}
	}
}


/*
 * Inner function for ffLDL_fft(). It expects the matrix to be both
 * auto-adjoint and quasicyclic; also, it uses the source operands
 * as modifiable temporaries.
 *
 * tmp[] must have room for at least one polynomial.
 */
void ffLDL_fft_inner(fpr * tree, fpr * g0, fpr * g1, unsigned logn, fpr * tmp)
{
	size_t n, hn;
	// printf("%d, ", g1-base_address);
	// printf("%d, ", tree-tree_base_address);

	n = MKN(logn);
	if (n == 1) {
		tree[0] = g0[0];
		return;
	}
	hn = n >> 1;


	/*
	 * The LDL decomposition yields L (which is written in the tree)
	 * and the diagonal of D. Since d00 = g0, we just write d11
	 * into tmp.
	 */
	poly_LDLmv_fft(tmp, tree, g0, g1, g0, logn);

	/*
	 * Split d00 (currently in g0) and d11 (currently in tmp). We
	 * reuse g0 and g1 as temporary storage spaces:
	 *   d00 splits into g1, g1+hn
	 *   d11 splits into g0, g0+hn
	 */
	poly_split_fft(g1, g1 + hn, g0, logn);
	poly_split_fft(g0, g0 + hn, tmp, logn);

	/*
	 * Each split result is the first row of a new auto-adjoint
	 * quasicyclic matrix for the next recursive step.
	 */

	ffLDL_fft_inner(tree + n, g1, g1 + hn, logn - 1, tmp);
	ffLDL_fft_inner(tree + n + ffLDL_treesize(logn - 1), g0, g0 + hn, logn - 1, tmp);
}

/*
 * Compute the ffLDL tree of an auto-adjoint matrix G. The matrix
 * is provided as three polynomials (FFT representation).
 *
 * The "tree" array is filled with the computed tree, of size
 * (logn+1)*(2^logn) elements (see ffLDL_treesize()).
 *
 * Input arrays MUST NOT overlap, except possibly the three unmodified
 * arrays g00, g01 and g11. tmp[] should have room for at least three
 * polynomials of 2^logn elements each.
 */
void ffLDL_fft(fpr *tree, const fpr *g00,
	const fpr *g01, const fpr *g11,
	unsigned logn, fpr *tmp)
{
	size_t n, hn;
	fpr *d00, *d11;

	n = MKN(logn);
	if (n == 1) {
		printf("I get never executed right?");
		tree[0] = g00[0];
		return;
	}
	hn = n >> 1;
	d00 = tmp;
	d11 = tmp + n;
	tmp += n << 1;

	memcpy(d00, g00, n * sizeof *g00);
	poly_LDLmv_fft(d11, tree, g00, g01, g11, logn);

	poly_split_fft(tmp, tmp + hn, d00, logn);
	poly_split_fft(d00, d00 + hn, d11, logn);
	memcpy(d11, tmp, n * sizeof *tmp);

	// printf("TEST %d \n",  hn);
	// printf("expanded_key  \n");
	// for(int i = 0; i<1024;++i)
	// 	if(i % 30 == 0)
	// 		printf("%ld, \n ", d11[i]);
	// 	else
	// 		printf("%ld, ", d11[i]);
	// printf("\n \n");


	ffLDL_fft_inner_it(tree + n, d00, logn - 1, tmp);
	// ffLDL_fft_inner_it(tree + n + ffLDL_treesize(logn - 1), d00, d00 + hn, logn - 1, tmp);
	
	// tree_base_address = tree + n;
	// base_address = d00;
	// ffLDL_fft_inner(tree + n, d11, d11 + hn, logn - 1, tmp);
	// ffLDL_fft_inner(tree + n + ffLDL_treesize(logn - 1), d00, d00 + hn, logn - 1, tmp);

}

void ffLDL_binary_normalize_it(fpr *tree, unsigned orig_logn, unsigned logn)
{
	/*
	 * TODO: make an iterative version.
	 */
	size_t n;

	// int n_it = 1023;
	// const int8_t *logn_normalize_tree = logn_normalize_tree512;
	// const int16_t *tree_normalize_offset = tree_normalize_offset512;

	int n_it = 2047;
	const int8_t *logn_normalize_tree = logn_normalize_tree1024;
	const int16_t *tree_normalize_offset = tree_normalize_offset1024;


	for(int i = 0; i < n_it; ++i){
		n = MKN(logn_normalize_tree[i]);
		if (n == 1) {
					/*
			* We actually store in the tree leaf the inverse of
			* the value mandated by the specification: this
			* saves a division both here and in the sampler.
			*/
			*(tree+tree_normalize_offset[i]) = fpr_mul(fpr_sqrt(*(tree+tree_normalize_offset[i])), fpr_inv_sigma[orig_logn]);
		}
	}
}

/*
 * Normalize an ffLDL tree: each leaf of value x is replaced with
 * sigma / sqrt(x).
 */
void ffLDL_binary_normalize(fpr *tree, unsigned orig_logn, unsigned logn)
{
	/*
	 * TODO: make an iterative version.
	 */
	size_t n;
	global_cnt++;
	if (global_cnt % 30 == 0)
		printf("%ld, \n",tree - tree_base_address);
	else
		printf("%ld, ", tree- tree_base_address);
	n = MKN(logn);
	if (n == 1) {
		/*
		 * We actually store in the tree leaf the inverse of
		 * the value mandated by the specification: this
		 * saves a division both here and in the sampler.
		 */
		tree[0] = fpr_mul(fpr_sqrt(tree[0]), fpr_inv_sigma[orig_logn]);
	} else {
		ffLDL_binary_normalize(tree + n, orig_logn, logn - 1);
		ffLDL_binary_normalize(tree + n + ffLDL_treesize(logn - 1), orig_logn, logn - 1);
	}
}

/* =================================================================== */

/*
 * Convert an integer polynomial (with small values) into the
 * representation with complex numbers.
 */
void smallints_to_fpr(fpr *r, const int8_t *t, unsigned logn)
{
	size_t n, u;

	n = MKN(logn);
	for (u = 0; u < n; u ++) {
		r[u] = fpr_of(t[u]);
	}
}

/*
 * The expanded private key contains:
 *  - The B0 matrix (four elements)
 *  - The ffLDL tree
 */

size_t skoff_b00(unsigned logn)
{
	(void)logn;
	return 0;
}

size_t skoff_b01(unsigned logn)
{
	return MKN(logn);
}


size_t skoff_b10(unsigned logn)
{
	return 2 * MKN(logn);
}

size_t skoff_b11(unsigned logn)
{
	return 3 * MKN(logn);
}

size_t  skoff_tree(unsigned logn)
{
	return 4 * MKN(logn);
}


/*
 * Expand a private key into the B0 matrix in FFT representation and
 * the LDL tree. All the values are written in 'expanded_key', for
 * a total of (8*logn+40)*2^logn bytes.
 *
 * The tmp[] array must have room for at least 48*2^logn bytes.
 *
 * tmp[] must have 64-bit alignment.
 * This function uses floating-point rounding (see set_fpu_cw()).
 */

void expand_privkey(fpr expanded_key[7168], const int8_t f[512], const int8_t g[512], const int8_t F_upper[512], const int8_t G_upper[512])
// void expand_privkey(fpr expanded_key[15360], const int8_t f[1024], const int8_t g[1024], const int8_t F_upper[1024], const int8_t G_upper[1024])
{

#pragma HLS INTERFACE mode=m_axi port=f bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=g bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=F_upper bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=G_upper bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=expanded_key bundle=gmem0 offset=slave
#pragma HLS INTERFACE s_axilite port=return


	size_t n;
	fpr *rf, *rg, *rF, *rG;
	fpr *b00, *b01, *b10, *b11;
	fpr *g00, *g01, *g11, *gxx;
	fpr *tree;

	unsigned logn = 10;
	n = MKN(logn);
	uint8_t tmp[48*n];

	b00 = expanded_key + skoff_b00(logn);
	b01 = expanded_key + skoff_b01(logn);
	b10 = expanded_key + skoff_b10(logn);
	b11 = expanded_key + skoff_b11(logn);
	tree = expanded_key + skoff_tree(logn);

	/*
	 * We load the private key elements directly into the B0 matrix,
	 * since B0 = [[g, -f], [G, -F]].
	 */
	rf = b01;
	rg = b00;
	rF = b11;
	rG = b10;

	smallints_to_fpr(rf, f, logn);
	smallints_to_fpr(rg, g, logn);
	smallints_to_fpr(rF, F_upper, logn);
	smallints_to_fpr(rG, G_upper, logn);

	/*
	 * Compute the FFT for the key elements, and negate f and F.
	 */
	FFT(rf, logn);
	FFT(rg, logn);
	FFT(rF, logn);
	FFT(rG, logn);
	poly_neg(rf, logn);
	poly_neg(rF, logn);

	/*
	 * The Gram matrix is G = B·B*. Formulas are:
	 *   g00 = b00*adj(b00) + b01*adj(b01)
	 *   g01 = b00*adj(b10) + b01*adj(b11)
	 *   g10 = b10*adj(b00) + b11*adj(b01)
	 *   g11 = b10*adj(b10) + b11*adj(b11)
	 *
	 * For historical reasons, this implementation uses
	 * g00, g01 and g11 (upper triangle).
	 */
	g00 = (fpr *)tmp;
	g01 = g00 + n;
	g11 = g01 + n;
	gxx = g11 + n;

	memcpy(g00, b00, n * sizeof *b00);
	poly_mulselfadj_fft(g00, logn);
	memcpy(gxx, b01, n * sizeof *b01);
	poly_mulselfadj_fft(gxx, logn);
	poly_add(g00, gxx, logn);

	memcpy(g01, b00, n * sizeof *b00);
	poly_muladj_fft(g01, b10, logn);
	memcpy(gxx, b01, n * sizeof *b01);
	poly_muladj_fft(gxx, b11, logn);
	poly_add(g01, gxx, logn);

	memcpy(g11, b10, n * sizeof *b10);
	poly_mulselfadj_fft(g11, logn);
	memcpy(gxx, b11, n * sizeof *b11);
	poly_mulselfadj_fft(gxx, logn);
	poly_add(g11, gxx, logn);

	/*
	 * Compute the Falcon tree.
	 */
	ffLDL_fft(tree, g00, g01, g11, logn, gxx);

	/*
	 * Normalize tree.
	 */
	// tree_base_address = tree;

	ffLDL_binary_normalize_it(tree, logn, logn);
	// ffLDL_binary_normalize(tree, logn, logn);

}


/*
 * Perform Fast Fourier Sampling for target vector t and LDL tree T.
 * tmp[] must have size for at least two polynomials of size 2^logn.
 */

/*
 * Compute a signature: the signature contains two vectors, s1 and s2.
 * The s1 vector is not returned. The squared norm of (s1,s2) is
 * computed, and if it is short enough, then s2 is returned into the
 * s2[] buffer, and 1 is returned; otherwise, s2[] is untouched and 0 is
 * returned; the caller should then try again. This function uses an
 * expanded key.
 *
 * tmp[] must have room for at least six polynomials.
 */
int do_sign_tree(void *samp_ctx, int16_t *s2,
	const fpr *expanded_key,
	const uint16_t *hm,
	unsigned logn)
{

	size_t n, u;
	fpr *t0, *t1, *tx, *ty;
	const fpr *b00, *b01, *b10, *b11, *tree;
	fpr ni;
	uint32_t sqn, ng;
	n = MKN(logn);

	fpr tmp[6*n];
	t0 = tmp;
	t1 = t0 + n;
	b00 = expanded_key + skoff_b00(logn);
	b01 = expanded_key + skoff_b01(logn);
	b10 = expanded_key + skoff_b10(logn);
	b11 = expanded_key + skoff_b11(logn);
	tree = expanded_key + skoff_tree(logn);

	/*
	 * Set the target vector to [hm, 0] (hm is the hashed message).
	 */

	for (u = 0; u < n; u ++) {
		t0[u] = fpr_of(hm[u]);
		// /* This is implicit.
		// t1[u] = fpr_zero;
		
	}
	/*
	 * Apply the lattice basis to obtain the real target
	 * vector (after normalization with regards to modulus).
	 */
	
	FFT(t0, logn);
	ni = fpr_inverse_of_q;
	memcpy(t1, t0, n * sizeof *t0);
	poly_mul_fft(t1, b01, logn);
	poly_mulconst(t1, fpr_neg(ni), logn);
	poly_mul_fft(t0, b11, logn);
	poly_mulconst(t0, ni, logn);

	tx = t1 + n;
	ty = tx + n;

	/*
	 * Apply sampling. Output is written back in [tx, ty].
	 */
	// tree_base_address = tree;
	// base_address = t0;
	ffSampling_fft_it(samp_ctx, tree, t0);
	// ffSampling_fft(samp_ctx, tx, ty, tree, t0, t1, logn, ty + n);
	/*
	 * Get the lattice point corresponding to that tiny vector.
	 */


	memcpy(t0, tx, n * sizeof *tx);
	memcpy(t1, ty, n * sizeof *ty);
	poly_mul_fft(tx, b00, logn);
	poly_mul_fft(ty, b10, logn);
	poly_add(tx, ty, logn);
	memcpy(ty, t0, n * sizeof *t0);
	poly_mul_fft(ty, b01, logn);
	memcpy(t0, tx, n * sizeof *tx);
	poly_mul_fft(t1, b11, logn);
	poly_add(t1, ty, logn);
	iFFT(t0, logn);
	iFFT(t1, logn);

	/*
	 * Compute the signature.
	 */
	int16_t s1tmp[1024];
	sqn = 0;
	ng = 0;
	for (u = 0; u < n; u ++) {
		int32_t z;

		z = (int32_t)hm[u] - (int32_t)fpr_rint(t0[u]);
		sqn += (uint32_t)(z * z);
		ng |= sqn;
		s1tmp[u] = (int16_t)z;
	}
	sqn |= -(ng >> 31);
	/*
	 * With "normal" degrees (e.g. 512 or 1024), it is very
	 * improbable that the computed vector is not short enough;
	 * however, it may happen in practice for the very reduced
	 * versions (e.g. degree 16 or below). In that case, the caller
	 * will loop, and we must not write anything into s2[] because
	 * s2[] may overlap with the hashed message hm[] and we need
	 * hm[] for the next iteration.
	 */
	int16_t s2tmp[1024];
	for (u = 0; u < n; u ++) {
		s2tmp[u] = (int16_t)-fpr_rint(t1[u]);
	}

	if (is_short_half(sqn, s2tmp, logn)) {
		memcpy(s2, s2tmp, n * sizeof *s2);
		return 1;
	}
	return 0;
	// return 1;
}


/*
 * Sample an integer value along a half-gaussian distribution centered
 * on zero and standard deviation 1.8205, with a precision of 72 bits.
 */
int64_t gaussian0_sampler(prng *p)
{

	static const uint32_t dist[] = {
		10745844u,  3068844u,  3741698u,
		 5559083u,  1580863u,  8248194u,
		 2260429u, 13669192u,  2736639u,
		  708981u,  4421575u, 10046180u,
		  169348u,  7122675u,  4136815u,
		   30538u, 13063405u,  7650655u,
		    4132u, 14505003u,  7826148u,
		     417u, 16768101u, 11363290u,
		      31u,  8444042u,  8086568u,
		       1u, 12844466u,   265321u,
		       0u,  1232676u, 13644283u,
		       0u,    38047u,  9111839u,
		       0u,      870u,  6138264u,
		       0u,       14u, 12545723u,
		       0u,        0u,  3104126u,
		       0u,        0u,    28824u,
		       0u,        0u,      198u,
		       0u,        0u,        1u
	};

	uint32_t v0, v1, v2, hi;
	uint64_t lo;
	size_t u;
	int64_t z;

	/*
	 * Get a random 72-bit value, into three 24-bit limbs v0..v2.
	 */
	lo = prng_get_u64(p);
	hi = prng_get_u8(p);
	v0 = (uint32_t)lo & 0xFFFFFF;
	v1 = (uint32_t)(lo >> 24) & 0xFFFFFF;
	v2 = (uint32_t)(lo >> 48) | (hi << 16);

	/*
	 * Sampled value is z, such that v0..v2 is lower than the first
	 * z elements of the table.
	 */
	z = 0;
	for (u = 0; u < (sizeof dist) / sizeof(dist[0]); u += 3) {
		uint32_t w0, w1, w2, cc;

		w0 = dist[u + 2];
		w1 = dist[u + 1];
		w2 = dist[u + 0];
		cc = (v0 - w0) >> 31;
		cc = (v1 - w1 - cc) >> 31;
		cc = (v2 - w2 - cc) >> 31;
		z += (int64_t)cc;
	}
	return z;

}

/*
 * Sample a bit with probability exp(-x) for some x >= 0.
 */
int BerExp(prng *p, fpr x, fpr ccs)
{
	int64_t s, i;
	fpr r;
	uint32_t sw, w;
	uint64_t z;

	/*
	 * Reduce x modulo log(2): x = s*log(2) + r, with s an integer,
	 * and 0 <= r < log(2). Since x >= 0, we can use fpr_trunc().
	 */
	s = fpr_trunc(fpr_mul(x, fpr_inv_log2));
	r = fpr_sub(x, fpr_mul(fpr_of(s), fpr_log2));

	/*
	 * It may happen (quite rarely) that s >= 64; if sigma = 1.2
	 * (the minimum value for sigma), r = 0 and b = 1, then we get
	 * s >= 64 if the half-Gaussian produced a z >= 13, which happens
	 * with probability about 0.000000000230383991, which is
	 * approximatively equal to 2^(-32). In any case, if s >= 64,
	 * then BerExp will be non-zero with probability less than
	 * 2^(-64), so we can simply saturate s at 63.
	 */
	sw = (uint32_t)s;
	sw ^= (sw ^ 63) & -((63 - sw) >> 31);
	s = (int)sw;

	/*
	 * Compute exp(-r); we know that 0 <= r < log(2) at this point, so
	 * we can use fpr_expm_p63(), which yields a result scaled to 2^63.
	 * We scale it up to 2^64, then right-shift it by s bits because
	 * we really want exp(-x) = 2^(-s)*exp(-r).
	 *
	 * The "-1" operation makes sure that the value fits on 64 bits
	 * (i.e. if r = 0, we may get 2^64, and we prefer 2^64-1 in that
	 * case). The bias is negligible since fpr_expm_p63() only computes
	 * with 51 bits of precision or so.
	 */
	z = ((fpr_expm_p63(r, ccs) << 1) - 1) >> s;

	/*
	 * Sample a bit with probability exp(-x). Since x = s*log(2) + r,
	 * exp(-x) = 2^-s * exp(-r), we compare lazily exp(-x) with the
	 * PRNG output to limit its consumption, the sign of the difference
	 * yields the expected result.
	 */
	i = 64;
	do {
		i -= 8;
		w = prng_get_u8(p) - ((uint32_t)(z >> i) & 0xFF);
#pragma HLS LOOP_TRIPCOUNT max=1
	} while (!w && i > 0);
	return (int)(w >> 31);
}




/*
 * The sampler produces a random integer that follows a discrete Gaussian
 * distribution, centered on mu, and with standard deviation sigma. The
 * provided parameter isigma is equal to 1/sigma.
 *
 * The value of sigma MUST lie between 1 and 2 (i.e. isigma lies between
 * 0.5 and 1); in Falcon, sigma should always be between 1.2 and 1.9.
 */
// int64_t sampler(void *ctx, fpr mu, fpr isigma, fpr *dss_out, fpr *a_out, fpr *b2_out, fpr *c_out, fpr *d_out, fpr *e_out)
int64_t sampler(void *ctx, fpr mu, fpr isigma)
{
	sampler_context *spc;
	int64_t s;
	fpr r, dss, ccs;
	fpr z_fp, s_fp;
	spc = ctx;

	/*
	 * Center is mu. We compute mu = s + r where s is an integer
	 * and 0 <= r < 1.
	 */
	s = fpr_floor(mu);
	s_fp = fpr_of(s);
	r = fpr_sub(mu,s_fp);

	/*
	 * dss = 1/(2*sigma^2) = 0.5*(isigma^2).
	 */
	dss = fpr_half(fpr_sqr(isigma));

	/*
	 * ccs = sigma_min / sigma = sigma_min * isigma.
	 */
	ccs = fpr_mul(isigma, spc->sigma_min);

	
	/*
	 * We now need to sample on center r.
	 */
	// int cnt = 0;
	for (;;) {
#pragma HLS LOOP_TRIPCOUNT max=1
		int64_t z0, z, b;
		fpr x;
		// cnt++;
		/*
		 * Sample z for a Gaussian distribution. Then get a
		 * random bit b to turn the sampling into a bimodal
		 * distribution: if b = 1, we use z+1, otherwise we
		 * use -z. We thus have two situations:
		 *
		 *  - b = 1: z >= 1 and sampled against a Gaussian
		 *    centered on 1.
		 *  - b = 0: z <= 0 and sampled against a Gaussian
		 *    centered on 0.
		 */
		z0 = gaussian0_sampler(&spc->p);
		b = (int64_t)prng_get_u8(&spc->p) & 1;
		z = b + ((b << 1) - 1) * z0;
		z_fp = fpr_of(z);
		/*
		 * Rejection sampling. We want a Gaussian centered on r;
		 * but we sampled against a Gaussian centered on b (0 or
		 * 1). But we know that z is always in the range where
		 * our sampling distribution is greater than the Gaussian
		 * distribution, so rejection works.
		 *
		 * We got z with distribution:
		 *    G(z) = exp(-((z-b)^2)/(2*sigma0^2))
		 * We target distribution:
		 *    S(z) = exp(-((z-r)^2)/(2*sigma^2))
		 * Rejection sampling works by keeping the value z with
		 * probability S(z)/G(z), and starting again otherwise.
		 * This requires S(z) <= G(z), which is the case here.
		 * Thus, we simply need to keep our z with probability:
		 *    P = exp(-x)
		 * where:
		 *    x = ((z-r)^2)/(2*sigma^2) - ((z-b)^2)/(2*sigma0^2)
		 *
		 * Here, we scale up the Bernouilli distribution, which
		 * makes rejection more probable, but makes rejection
		 * rate sufficiently decorrelated from the Gaussian
		 * center and standard deviation that the whole sampler
		 * can be said to be constant-time.
		 */
		x = fpr_mul(fpr_sqr(fpr_sub(z_fp, r)), dss);
		x = fpr_sub(x, fpr_mul(fpr_of(z0 * z0), fpr_inv_2sqrsigma0));
		if (BerExp(&spc->p, x, ccs)) {
		// 	/*
		// 	 * Rejection sampling was centered on r, but the
		// 	 * actual center is mu = s + r.
		// 	 */
			return s + z;
		}
	}
}


// double in = -1.230000 
// int out = -2 
// double out = -2.000000 
// double out2 = -2.000000 

// double in = -1.230000
// int out = -2 
// double out = 4294967294.000000 
// double out2 = -2.000000 

void bug(double *in, double *out, double *out2, int32_t *out_int){
#pragma HLS INTERFACE mode=m_axi port=in bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=out bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=out2 bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=out_int bundle=gmem0 offset=slave
#pragma HLS INTERFACE s_axilite port=return

	int32_t x_int;
	int32_t x_int_const = -2;
	
	double x_float, x_float_const;

	// x_int = fpr_floor(*in);
	x_int = (int32_t)fpr_floor(*in);

	*out_int = x_int;

	x_float = (double)x_int;


	x_float_const = (double)x_int_const;

	*out = x_float;
	*out2 = x_float_const;

}


void sign_tree_expand(int16_t sig[1024], const int8_t f[1024], const int8_t g[1024], const int8_t F_upper[1024], const int8_t G_upper[], uint16_t hm[1024], uint8_t seed[48])
{

#pragma HLS INTERFACE mode=m_axi port=f bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=g bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=F_upper bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=G_upper bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=sig bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=seed bundle=gmem0 offset=slave
// #pragma HLS INTERFACE mode=m_axi port=expanded_key bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=hm bundle=gmem0 offset=slave
#pragma HLS INTERFACE s_axilite port=return

	unsigned logn = 10;

//	fpr ftmp[6*1024];

	inner_shake256_context rng;
	#pragma HLS array_partition variable=rng type=complete
	fpr expanded_key[15360];

	expand_privkey(expanded_key, f, g, F_upper, G_upper);

	i_shake256_init(&rng);
	i_shake256_inject(&rng, seed, 48);
	i_shake256_flip(&rng);
	
	for (;;) {
		/*
		 * Signature produces short vectors s1 and s2. The
		 * signature is acceptable only if the aggregate vector
		 * s1,s2 is short; we must use the same bound as the
		 * verifier.
		 *
		 * If the signature is acceptable, then we return only s2
		 * (the verifier recomputes s1 from s2, the hashed message,
		 * and the public key).
		 */
		sampler_context spc;
		// samplerZ samp;
		void *samp_ctx;

		/*
		 * Normal sampling. We use a fast PRNG seeded from our
		 * SHAKE context ('rng').
		 */
		spc.sigma_min = fpr_sigma_min[logn];
		prng_init(&spc.p, &rng);
		// samp = sampler;
		samp_ctx = &spc;

		/*
		 * Do the actual signature.
		 */
	

		if (do_sign_tree(samp_ctx, sig, expanded_key, hm, logn))
		{
			break;
		}
	}
}
/*
 * Compute a signature: the signature contains two vectors, s1 and s2.
 * The s1 vector is not returned. The squared norm of (s1,s2) is
 * computed, and if it is short enough, then s2 is returned into the
 * s2[] buffer, and 1 is returned; otherwise, s2[] is untouched and 0 is
 * returned; the caller should then try again.
 *
 * tmp[] must have room for at least nine polynomials.
 */
int do_sign_dyn(void *samp_ctx, int16_t *s2,
	const int8_t *f, const int8_t *g,
	const int8_t *F, const int8_t *G,
	const uint16_t *hm, unsigned logn, fpr *tmp)
{
	size_t n, u;
	fpr *t0, *t1, *tx, *ty;
	fpr *b00, *b01, *b10, *b11, *g00, *g01, *g11;
	fpr ni;
	uint32_t sqn, ng;
	int16_t *s1tmp, *s2tmp;
	// logn = 10;
	n = MKN(logn);

	// fpr tmp[9*1024];
	/*
	 * Lattice basis is B = [[g, -f], [G, -F]]. We convert it to FFT.
	 */
	b00 = tmp;
	b01 = b00 + n;
	b10 = b01 + n;
	b11 = b10 + n;
	smallints_to_fpr(b01, f, logn);
	smallints_to_fpr(b00, g, logn);
	smallints_to_fpr(b11, F, logn);
	smallints_to_fpr(b10, G, logn);
	FFT(b01, logn);
	FFT(b00, logn);
	FFT(b11, logn);
	FFT(b10, logn);
	poly_neg(b01, logn);
	poly_neg(b11, logn);

	/*
	 * Compute the Gram matrix G = B·B*. Formulas are:
	 *   g00 = b00*adj(b00) + b01*adj(b01)
	 *   g01 = b00*adj(b10) + b01*adj(b11)
	 *   g10 = b10*adj(b00) + b11*adj(b01)
	 *   g11 = b10*adj(b10) + b11*adj(b11)
	 *
	 * For historical reasons, this implementation uses
	 * g00, g01 and g11 (upper triangle). g10 is not kept
	 * since it is equal to adj(g01).
	 *
	 * We _replace_ the matrix B with the Gram matrix, but we
	 * must keep b01 and b11 for computing the target vector.
	 */
	t0 = b11 + n;
	t1 = t0 + n;

	memcpy(t0, b01, n * sizeof *b01);
	poly_mulselfadj_fft(t0, logn);    // t0 <- b01*adj(b01)

	memcpy(t1, b00, n * sizeof *b00);
	poly_muladj_fft(t1, b10, logn);   // t1 <- b00*adj(b10)
	poly_mulselfadj_fft(b00, logn);   // b00 <- b00*adj(b00)
	poly_add(b00, t0, logn);      // b00 <- g00
	memcpy(t0, b01, n * sizeof *b01);
	poly_muladj_fft(b01, b11, logn);  // b01 <- b01*adj(b11)
	poly_add(b01, t1, logn);      // b01 <- g01

	poly_mulselfadj_fft(b10, logn);   // b10 <- b10*adj(b10)
	memcpy(t1, b11, n * sizeof *b11);
	poly_mulselfadj_fft(t1, logn);    // t1 <- b11*adj(b11)
	poly_add(b10, t1, logn);      // b10 <- g11

	/*
	 * We rename variables to make things clearer. The three elements
	 * of the Gram matrix uses the first 3*n slots of tmp[], followed
	 * by b11 and b01 (in that order).
	 */
	g00 = b00;
	g01 = b01;
	g11 = b10;
	b01 = t0;
	t0 = b01 + n;
	t1 = t0 + n;

	/*
	 * Memory layout at that point:
	 *   g00 g01 g11 b11 b01 t0 t1
	 */

	/*
	 * Set the target vector to [hm, 0] (hm is the hashed message).
	 */

	for (u = 0; u < n; u ++) {
		t0[u] = fpr_of(hm[u]);
		/* This is implicit.
		t1[u] = fpr_zero;
		*/
	}

	/*
	 * Apply the lattice basis to obtain the real target
	 * vector (after normalization with regards to modulus).
	 */
	FFT(t0, logn);
	ni = fpr_inverse_of_q;
	memcpy(t1, t0, n * sizeof *t0);
	poly_mul_fft(t1, b01, logn);
	poly_mulconst(t1, fpr_neg(ni), logn);
	poly_mul_fft(t0, b11, logn);
	poly_mulconst(t0, ni, logn);

	/*
	 * b01 and b11 can be discarded, so we move back (t0,t1).
	 * Memory layout is now:
	 *      g00 g01 g11 t0 t1
	 */
	memcpy(b11, t0, n * 2 * sizeof *t0);
	t0 = g11 + n;
	t1 = t0 + n;

	/*
	 * Apply sampling; result is written over (t0,t1).
	 */
	// global_cnt = 0;


	ffSampling_fft_dyntree(samp_ctx, t0, t1, g00, g01, g11, logn, logn, t1 + n);


	// printf("cnt = %d", global_cnt);
	/*
	 * We arrange the layout back to:
	 *     b00 b01 b10 b11 t0 t1
	 *
	 * We did not conserve the matrix basis, so we must recompute
	 * it now.
	 */
	b00 = tmp;
	b01 = b00 + n;
	b10 = b01 + n;
	b11 = b10 + n;
	memmove(b11 + n, t0, n * 2 * sizeof *t0);
	t0 = b11 + n;
	t1 = t0 + n;
	smallints_to_fpr(b01, f, logn);
	smallints_to_fpr(b00, g, logn);
	smallints_to_fpr(b11, F, logn);
	smallints_to_fpr(b10, G, logn);
	FFT(b01, logn);
	FFT(b00, logn);
	FFT(b11, logn);
	FFT(b10, logn);
	poly_neg(b01, logn);
	poly_neg(b11, logn);
	tx = t1 + n;
	ty = tx + n;

	/*
	 * Get the lattice point corresponding to that tiny vector.
	 */
	memcpy(tx, t0, n * sizeof *t0);
	memcpy(ty, t1, n * sizeof *t1);
	poly_mul_fft(tx, b00, logn);
	poly_mul_fft(ty, b10, logn);
	poly_add(tx, ty, logn);
	memcpy(ty, t0, n * sizeof *t0);
	poly_mul_fft(ty, b01, logn);

	memcpy(t0, tx, n * sizeof *tx);
	poly_mul_fft(t1, b11, logn);
	poly_add(t1, ty, logn);
	iFFT(t0, logn);
	iFFT(t1, logn);

	s1tmp = (int16_t *)tx;
	sqn = 0;
	ng = 0;
	for (u = 0; u < n; u ++) {
		int32_t z;

		z = (int32_t)hm[u] - (int32_t)fpr_rint(t0[u]);
		sqn += (uint32_t)(z * z);
		ng |= sqn;
		s1tmp[u] = (int16_t)z;
	}
	sqn |= -(ng >> 31);

	/*
	 * With "normal" degrees (e.g. 512 or 1024), it is very
	 * improbable that the computed vector is not short enough;
	 * however, it may happen in practice for the very reduced
	 * versions (e.g. degree 16 or below). In that case, the caller
	 * will loop, and we must not write anything into s2[] because
	 * s2[] may overlap with the hashed message hm[] and we need
	 * hm[] for the next iteration.
	 */
	s2tmp = (int16_t *)tmp;
	for (u = 0; u < n; u ++) {
		s2tmp[u] = (int16_t)-fpr_rint(t1[u]);
	}
	if (is_short_half(sqn, s2tmp, logn)) {
		memcpy(s2, s2tmp, n * sizeof *s2);
		memcpy(tmp, s1tmp, n * sizeof *s1tmp);
		return 1;
	}
	return 0;
}


/*
 * Compute a signature over the provided hashed message (hm); the
 * signature value is one short vector. This function uses an
 * expanded key (as generated by Zf(expand_privkey)()).
 *
 * The sig[] and hm[] buffers may overlap.
 *
 * On successful output, the start of the tmp[] buffer contains the s1
 * vector (as int16_t elements).
 *
 * The minimal size (in bytes) of tmp[] is 48*2^logn bytes.
 *
 * tmp[] must have 64-bit alignment.
 * This function uses floating-point rounding (see set_fpu_cw()).
 */
void sign_tree(int16_t sig[1024], fpr expanded_key[15360], uint16_t hm[1024], uint8_t msg[50], uint8_t seed[48])
{

#pragma HLS INTERFACE mode=m_axi port=sig bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=seed bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=expanded_key bundle=gmem0 offset=slave
#pragma HLS INTERFACE mode=m_axi port=hm bundle=gmem0 offset=slave
#pragma HLS INTERFACE s_axilite port=return

	unsigned logn = 10;

		// uint8_t msg[50];  /* nonce + plain */
		inner_shake256_context sc;


		i_shake256_init(&sc);
		i_shake256_inject(&sc, msg, sizeof msg);
		i_shake256_flip(&sc);

		hash_to_point_vartime(&sc, hm, logn);


	inner_shake256_context rng;
#pragma HLS array_partition variable=rng type=complete

	i_shake256_init(&rng);
	i_shake256_inject(&rng, seed, 48);
	i_shake256_flip(&rng);
	
		for(;;){
#pragma HLS LOOP_TRIPCOUNT max=1
		/*
		 * Signature produces short vectors s1 and s2. The
		 * signature is acceptable only if the aggregate vector
		 * s1,s2 is short; we must use the same bound as the
		 * verifier.
		 *
		 * If the signature is acceptable, then we return only s2
		 * (the verifier recomputes s1 from s2, the hashed message,
		 * and the public key).
		 */
		sampler_context spc;
		// samplerZ samp;
		void *samp_ctx;

		/*
		 * Normal sampling. We use a fast PRNG seeded from our
		 * SHAKE context ('rng').
		 */
		spc.sigma_min = fpr_sigma_min[logn];
		prng_init(&spc.p, &rng);
		// samp = sampler;
		samp_ctx = &spc;

		/*
		 * Do the actual signature.
		 */
		if (do_sign_tree(samp_ctx, sig, expanded_key, hm, logn))
		{
			break;
		}
	}
}

void sign_dyn(int16_t *sig, inner_shake256_context *rng,
	const int8_t *f, const int8_t *g,
	const int8_t *F, const int8_t *G,
	const uint16_t *hm, unsigned logn, uint8_t *tmp2)
{
	fpr *ftmp;
	uint8_t tmp[72*10214];
	logn = 10;
	ftmp = (fpr *)tmp;
		for(;;){
		/*
		 * Signature produces short vectors s1 and s2. The
		 * signature is acceptable only if the aggregate vector
		 * s1,s2 is short; we must use the same bound as the
		 * verifier.
		 *
		 * If the signature is acceptable, then we return only s2
		 * (the verifier recomputes s1 from s2, the hashed message,
		 * and the public key).
		 */
		sampler_context spc;
		// samplerZ samp;
		void *samp_ctx;

		/*
		 * Normal sampling. We use a fast PRNG seeded from our
		 * SHAKE context ('rng').
		 */
		spc.sigma_min = fpr_sigma_min[logn];
		prng_init(&spc.p, rng);
		// samp = sampler;
		samp_ctx = &spc;

		/*
		 * Do the actual signature.
		 */
		if (do_sign_dyn(samp_ctx, sig, f, g, F, G, hm, logn, ftmp))
		{
			break;
		}
	}

}
